#version 450

layout (local_size_x = 500, local_size_y = 1, local_size_x = 1) in;

layout (set = 0, binding = 0) buffer inputBuffer
{
    uvec4 valuesIn[2][2500];
};
layout (set = 0, binding = 1) buffer outputBuffer
{
    uint valuesOut[1];
};
layout (set = 0, binding = 2) uniform inputBuffer1
{
    uvec4 valuesIn1[2500];
};
layout (set = 0, binding = 3) uniform inputBuffer2
{
    uvec4 valuesIn2[2500];
};

uint preocessItems(uvec4 item1, uvec4 item2)
{
    mat4 value = outerProduct(item1, item2);
    vec4 maxValue = max(value[1], value[0]); 
    maxValue = max(maxValue, value[2]); 
    maxValue = max(maxValue, value[3]); 
    vec2 result2 = max(maxValue.rg, maxValue.ba);
    float result1 = max(result2[0], result2[1]);

    return uint(result1);
}


shared uint sharedResult[4];

void main()
{
    uint indexToSharedResult = gl_LocalInvocationID.x & 3;
    sharedResult[indexToSharedResult] = 0;

    memoryBarrierShared();

    uint index = gl_LocalInvocationID.x + gl_WorkGroupID.x * 500;
    uint result = preocessItems(valuesIn1[index], valuesIn2[gl_WorkGroupID.y]);

    atomicMax(sharedResult[indexToSharedResult], result);

    barrier();

    if(gl_LocalInvocationID.x == 0)
    {
        uint maxResult = max(sharedResult[0], sharedResult[1]);
        maxResult = max(maxResult, sharedResult[2]);
        maxResult = max(maxResult, sharedResult[3]);

        atomicMax(valuesOut[0], maxResult);
    }
}